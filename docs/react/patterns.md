---
title: Особенности написания компонентов react
---

import Link from '@docusaurus/Link';

### Концепция контейнерных компонентов и компонентов отображения
Каждый компонент должен быть либо умным компонентом либо глупым. Коннект редакса должен происходить только к умным компонентам, кроме случаев получения данных без возможности управления ими (mapDispatchToProps). Умные компоненты содержать разметку не могут и должны содержать лишь один компонент в рендере (render props не учитываются).
Компонент, соединенный с redux должен иметь префикс Connected. В свою очередь, дочерний компонент контейнера должен иметь постфикс View. Допускается не добавлять постфикс у компонентов отображения.
Контейнерный компонент должен быть написан через классовый компонент для упрощения чтения и для невозможности использования сторонних хуков библиотек. Нужно придерживаться минимальный связности компонентов со сторонними библиотеками когда это возможно. Это упрощает тестирование и чтение кода со сложной логикой тк в контейнерных компонентах содержится только логика. Методы компонентов пишем не используя синтаксис с .bind.
Контейнерные компоненты называются всегда одинакого - либо по имени компонента (если простое отделение умного от глупого компонента) либо WrappedContainer (если завернут в хок или в набор хоков). Для массового заворачивания в несколько хоков используется функция compose из redux


### Как определить лучше .map или чистая разметка в компоненте
Если в рендере мапа менее 5 статичных элементов - лучше map заменить на обычный рендеринг этих элементов для экономии ресурсов и понимания кода.


### Использование uniqId в ключах списка
Запрещается использовать уникальные ключи в списках и привлекать доп библиотеки для этого. Кроме какие то исключительных случаев.

### Логика в компонентах
Для упрощения чтения кода - необходимо максимально извлекать детали логических операций из компонентов в утилиты. Это упрощает чтение и тестирование кода - для утилиты будут свои тесты а для компонентов свои с мокнутыми утилитами для изоляции.

### Сторонние хуки
Нужно придерживаться минимальный связности компонентов со сторонними библиотеками когда это возможно. Также нужно придерживаться концепции чистых функций. Поскольку сторонние хуки библиотек это нарушают - их использование недопустимо. Необходимо заменять их на хоки.

### Мемоизация и оптимизация ссылок
Необходимо заворачивать вычисления в useMemo. Все функции должны быть завернуты в useCallback. Утечек памяти при этом случаться не будет, но по умолчанию проставляя эти хуки реакта будет нужно меньше задумываться о лишних вычислениях и перерисовках.
Также все компоненты должны быть завернуты в React.memo/React.PureComponent Кроме компонентов завернутых в connect - там внутри уже использован PureComponent.
Необходимо сделать оговорку, что нужно максимально мемоизировать вычисления в рендере компонента. Объясняется это тем, что js движок, за рядом исключений, однопоточный но при этом оперативной памяти на более менее современных устройствах огромное и в сравнении с потреблением памяти нашего проекте является пренебрежимо малым. 

### Запросы в компонентах
Компоненты реакт - слой отображения приложения. Он не должен отвечать за загрузку данных. Допускается наличие вызовов экшенов в контейнерных компонентах. Запросы к апи должны находиться в соответствующей мидлваре редакс (редакс-саги)


### Suspense
По умолчанию - все страницы приложения загружаются по требованию (лениво) благодаря настройкам роутера и могут загружаться предварительно (например при наведении мыши на раздел). Но пока компонент при медленном интернете загружается - нужно показывать скелетон. Его можно достать из библиотеки @wildberries/preview-component. Может быть несколько вариантов скелетона - выбирайте нужный для каждой страницы. Дополнительно Suspense ускоряет переходы между страницами особенно на мобильных устройствах.<Link to='https://youtu.be/Ax75Dc0UaFI'>Видео как использовать Suspence со скелетоном</Link>. Вкрадце можно отметить что Suspence должен использоваться только в page/index.tsx и отделять чанки с контентом страницы от пустой версии страницы

### Стили
В проектах используются sass-модули (css-модули совместно с sass) совметно с flexbox. Также в проектах используется БЭМ методология именования классов. Также используется библиотека classnames для упрощения конкатенации имен классов.
Стиль модификаторов выбран как "--".
Один БЭМ блок должен соответствовать одному компоненту реакт также должен быть вынесен в переменную для удобного переиспользования в компоненте.
Несмотря на возрастное решение - БЭМ позволяет организовать семантическую верстку.

- Переменную BLOCK_NAME (или имя БЭМ-блока) допускается писать как в формате BlockNameTest, так и в формате Block-name-test. Важно чтобы в проекте был единый стиль. Но так как раньше часто использовали и тот и другой подход - допустимо оставить возможными оба, но с поправкой на консистентноть имен в проекте. 


```typescript
import React, { memo, useCallback } from 'react';
import classnames from 'classnames/bind';
import i18next from 'i18next';
import {
  BasicMailIcon,
  ButtonLink,
  CallCallPhoneIcon,
} from '@wildberries/ui-kit';
import { PAGE_CONTENT_TRANSLATIONS } from '../../../../../../_constants/translations';
import styles from './index.module.scss';

const cn = classnames.bind(styles);

const BLOCK_NAME = 'Contacts';

type PropsType = {
    empty: boolean;
}

export const Contacts = memo(({ empty }) => {
  const PhoneIcon = useCallback(
    () => <CallCallPhoneIcon colorType="richGreyColor" />,
    [],
  );
  const MailIcon = useCallback(
    () => <BasicMailIcon colorType="richGreyColor" />,
    [],
  );

  return (
    // BEM Block
    <div className={cn(BLOCK_NAME)}>
        // BEM Element & BEM Modificator
      <div className={cn(`${BLOCK_NAME}__container`,{
        [`${BLOCK_NAME}__container--empty`]: empty
      })}>
        <ButtonLink
          isTextLeft
          routeName={i18next.t(PAGE_CONTENT_TRANSLATIONS.helpPhone)}
          target="_blank"
          text={i18next.t(PAGE_CONTENT_TRANSLATIONS.numberPhone)}
          textColor="darkPurple"
          variant="link"
        >
          {PhoneIcon}
        </ButtonLink>
        <ButtonLink
          isTextLeft
          routeName={`mailto:${i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}`}
          target="_blank"
          text={i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}
          textColor="darkPurple"
          variant="link"
        >
          {MailIcon}
        </ButtonLink>
      </div>
    </div>
  );
});
```


### Переводы
В проектах используются переводы и библиотека i18next. Это позволяет менять тексты без деплоя проекта. Кэш переводов выставлен на сутки. Но может быть сброшен в проекте. Достаточно указать что искользуется версионирование запроса к апи переводов и будет подставлена версия из гит тага.
Также использован ICU формат для склонения переводов.


### JSX
Нужно отбивать пробелом react-компоненты от html-элементов разметки. Между собой html-элементы не отбиваются, как и react-компоненты 

```typescript
    <div className={cn(BLOCK_NAME)}>
      <div className={cn(`${BLOCK_NAME}__container`,{
        [`${BLOCK_NAME}__container--empty`]: empty
      })}>
        <ButtonLink
          isTextLeft
          routeName={i18next.t(PAGE_CONTENT_TRANSLATIONS.helpPhone)}
          target="_blank"
          text={i18next.t(PAGE_CONTENT_TRANSLATIONS.numberPhone)}
          textColor="darkPurple"
          variant="link"
        >
          {PhoneIcon}
        </ButtonLink>
        <ButtonLink
          isTextLeft
          routeName={`mailto:${i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}`}
          target="_blank"
          text={i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}
          textColor="darkPurple"
          variant="link"
        >
          {MailIcon}
        </ButtonLink>
      </div>

      <ButtonLink
        isTextLeft
        routeName={`mailto:${i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}`}
        target="_blank"
        text={i18next.t(PAGE_CONTENT_TRANSLATIONS.helpMail)}
        textColor="darkPurple"
        variant="link"
      >
        {MailIcon}
      </ButtonLink>
    </div>
```